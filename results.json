{
    "tests": [
        {
            "score": 0,
            "max_score": 5,
            "name": "test_alignment.py::test_small_alignment",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 2,
            "name": "test_alignment.py::test_tiny_dna_alignment",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 3,
            "name": "test_alignment.py::test_tiny_dna_alignment_gaps",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 8,
            "name": "test_alignment.py::test_small_dna_alignment_not_banded",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 8,
            "name": "test_alignment.py::test_small_dna_alignment_banded",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 9,
            "name": "test_alignment.py::test_medium_dna_alignment",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 10,
            "name": "test_alignment.py::test_large_dna_alignment",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 10,
            "name": "test_alignment.py::test_large_dna_alignment_banded",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        },
        {
            "score": 0,
            "max_score": 10,
            "name": "test_alignment.py::test_massive_dna_alignment_banded",
            "output": "\nargs = (), kwargs = {}\n\n    @wraps(test_function)\n    def new_test_function(*args, **kwargs):\n        try:\n>           module = importlib.import_module(module_name)\n\nvenv/lib/python3.12/site-packages/byu_pytest_utils/utils.py:71: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3.12/importlib/__init__.py:90: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def align(\n            seq1: str,\n            seq2: str,\n            match_award=-3,\n            indel_penalty=5,\n            sub_penalty=1,\n            banded_width=-1,\n            gap='-'\n    ) -> tuple[float, str | None, str | None]:\n        \"\"\"\n            Align seq1 against seq2 using Needleman-Wunsch\n            Put seq1 on left (j) and seq2 on top (i)\n            => matrix[i][j]\n            :param seq1: the first sequence to align; should be on the \"left\" of the matrix\n            :param seq2: the second sequence to align; should be on the \"top\" of the matrix\n            :param match_award: how many points to award a match\n            :param indel_penalty: how many points to award a gap in either sequence\n            :param sub_penalty: how many points to award a substitution\n            :param banded_width: banded_width * 2 + 1 is the width of the banded alignment; -1 indicates full alignment\n            :param gap: the character to use to represent gaps in the alignment strings\n            :return: alignment cost, alignment 1, alignment 2\n        \"\"\"\n    \n        # matrix = TwoDimensionalListManager\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    class TwoDimensionalListManager:\n        def __init__(self, rows, cols):\n            \"\"\"\n            Initializes a new instance of the TwoDimensionalListManager class.\n    \n            Args:\n                rows (int): The number of rows in the matrix.\n                cols (int): The number of columns in the matrix.\n            \"\"\"\n            if rows <= 0 or cols <= 0:\n                raise ValueError(\"Both rows and columns must be positive.\")\n    \n            self.list_2d = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n        def add_row(self, row):\n            \"\"\"\n            Adds a new row to the 2D list.\n    \n            Args:\n                row (list): The new row to be added.\n            \"\"\"\n            if len(row) != len(self.list_2d[0]):\n                raise ValueError(\"All rows in the 2D list must have the same number of columns.\")\n            self.list_2d.append(row)\n    \n        def get_row(self, index):\n            \"\"\"\n            Gets a specific row from the 2D list.\n    \n            Args:\n                index (int): The index of the row to be retrieved.\n    \n            Returns:\n                list: The specified row.\n            \"\"\"\n            if index < 0 or index >= len(self.list_2d):\n                raise IndexError(\"Index out of range.\")\n            return self.list_2d[index]\n    \n        def get_column(self, column_index):\n            \"\"\"\n            Gets a specific column from the 2D list.\n    \n            Args:\n                column_index (int): The index of the column to be retrieved.\n    \n            Returns:\n                list: The specified column.\n            \"\"\"\n            if column_index < 0 or column_index >= len(self.list_2d[0]):\n                raise IndexError(\"Index out of range.\")\n            return [row[column_index] for row in self.list_2d]\n    \n        def print_list(self):\n            \"\"\"\n            Prints the entire 2D list.\n            \"\"\"\n            for row in self.list_2d:\n                print(row)\n    \n    \n    # Example usage:\n    \n>   manager = TwoDimensionalListManager()\nE   TypeError: TwoDimensionalListManager.__init__() missing 2 required positional arguments: 'rows' and 'cols'\n\nalignment.py:103: TypeError",
            "visibility": "visible"
        }
    ]
}